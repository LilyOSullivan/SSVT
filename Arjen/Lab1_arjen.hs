{-
  Group 12:
  Arjen Swartsenburg
  Stijn Veken
  Veno IvankoviÄ‡
  Eric van der Woude
-}

module Lab1 where
import Data.List
import Test.QuickCheck
import Test.QuickCheck.Modifiers (Positive)
import Data.Char (digitToInt)

prime :: Integer -> Bool
prime n = n > 1 && all (\ x -> rem n x /= 0) xs
  where xs = takeWhile (\ y -> y^2 <= n) primes

primes :: [Integer]
primes = 2 : filter prime [3..] 

infix 1 --> 

(-->) :: Bool -> Bool -> Bool
p --> q = not p || q

forall :: [a] -> (a -> Bool) -> Bool
forall = flip all

reversal :: Integer -> Integer
reversal = read . reverse . show

-- Assignment 1
induction1Left :: Integer -> Integer
induction1Left n = sum [1..n]

induction1Right :: Integer -> Integer
induction1Right n = (n * (n+1)) `div` 2

prop_Induction1 :: Integer -> Bool
prop_Induction1 n = (>0) n --> induction1Left n == induction1Right n

induction2Left :: Integer -> Integer
induction2Left n = sum [n^2 | n <- [1..n]]

induction2Right :: Integer -> Integer
induction2Right n = (n*(n+1) * (2*n+1)) `div` 6

prop_Induction2 :: Integer -> Bool
prop_Induction2 n = (>0) n --> induction2Left n == induction2Right n

induction3Left :: Integer -> Integer
induction3Left n = sum [n^3 | n <- [1..n]]

induction3Right :: Integer -> Integer
induction3Right n = ((n*(n+1)) `div` 2)^2

prop_Induction3 :: Integer -> Bool
prop_Induction3 n = (>0) n --> induction3Left n == induction3Right n

-- Assignment 2 20 min

prop_PowerSet :: Integer -> Property
prop_PowerSet n = 
  not (n < 1) ==>
  (length (subsequences [1..n])) === (2^(length [1..n]))

{-
  The property is hard to test as for every n + 1 the size of the list
  that is generated by the subsequences function grows exponentially.
  This makes it hard to test large values of n.
  When you perform this test you are actually testing wether the subsequences
  function works the way you would expect for positive integers.
-}

-- Assignment 3 60 min

perms :: [a] ->[[a]]
perms [] = [[]]
perms (x:xs) = concat (map (insrt x) (perms xs)) where
    insrt x [] = [[x]]
    insrt x (y:ys) = (x:y:ys) : map (y:) (insrt x ys)

induction5Left :: Int -> Int
induction5Left n = length (perms [1..n])

induction5Right :: Int -> Int
induction5Right n = product [1..n]

prop_Induction5 :: Int -> Bool
prop_Induction5 n = (>0) n --> induction5Left n == induction5Right n

{-|
  The property is tested by comparing the number of permutations from some input
  of the form [1..n] with n factorial. The results indicate if the perms function
  works. However, the property is hard to test with larger inputs and it is
  computationally demanding to make and then count all the 1307674368000
  permutations of [1..15], for example.
-}

-- Assignment 4

primesR :: [Integer]
primesR = filter (prime . reversal) $ takeWhile (<10000) primes

{-
  To test the primesR function, I would write a function that
  complements primesR, so that the primesRComplement function
  finds all primes less than 10000, so that the reversal is NOT prime.

  Then using quickcheck, I would see if the exclusive disjunction (XOR) of
  the answer space of primesR and primesRComplement equals the set of
  all primes less than 10000.
-}

-- Assignment 5

oprimes :: [Integer] -> Integer
oprimes xs
          | prime ( sum (take 101 xs)) = sum ( take 101 xs)
          | otherwise = oprimes (tail xs)

{-
  The opprimes function does not have to be tested. Finding the
  a sum of 101 primes, which is also prime is solved by means of bruteforce
  checking cases with a sliding window. This has parallels of proofing by
  exhaustion, were we look at each window of 101 primes and seeing if
  it delivers a smaller sum, which is also prime. All the cases checked by
  a proof by exhaustion check are a subset of the cases bruteforced by the
  opprimes function and therefore testing this function adds no value.
-}

-- Assignment 6

smallestCounterExample :: Int -> [Integer]
smallestCounterExample n
  | prime (1 + product (take n primes)) = smallestCounterExample (n + 1)
  | otherwise = take n primes

-- Assignment 7

reverseAndSplit :: Integer -> [Integer]
reverseAndSplit n = [toInteger (digitToInt n') | n' <- reverse (show n)]

doubleEveryOther :: [Integer] -> [Integer]
doubleEveryOther []          = []
doubleEveryOther [x]         = [x]
doubleEveryOther (x : y : z) = x : (y * 2) : doubleEveryOther z

sumDigits :: Integer -> Integer
sumDigits n = sum [toInteger (digitToInt n') | n' <- show n]

luhn :: Integer -> Bool
luhn n = sum ( map sumDigits (doubleEveryOther (reverseAndSplit n))) `mod` 10 == 0

isAmericanExpress :: Integer -> Bool
isAmericanExpress n = luhn n && nLength && (range34 || range37)
    where
      nLength = length (show n) == 15
      range34 = take 2 (show n) == "34"
      range37 = take 2 (show n) == "37"

isMaster :: Integer -> Bool
isMaster n = luhn n && nLength && (range5155 || range22212720)
    where
      nLength = length (show n) == 16
      range5155 = read (take 2 (show n)) >= 51 || read (take 2 (show n)) <= 55
      range22212720 = read (take 2 (show n)) >= 2221 || read (take 2 (show n)) <= 2720

isVisa :: Integer -> Bool
isVisa n = luhn n && nLength && range4
    where
      nLength = length (show n) == 16
      range4 = take 1 (show n) == "4"


-- I realise that I'm generating numbers with the same function that I'm testing, 
-- But I didn't have time to write a generate function.
-- Normally you would have a seperate function that generates

ccnum :: Gen Integer
ccnum = choose (100000000000000, 999999999999999) `suchThat` luhn

-- To test
-- > quickCheck (forAll ccnum prop_Luhn)
prop_Luhn :: Integer -> Bool
prop_Luhn = luhn

americanExpressNum :: Gen Integer
americanExpressNum = choose (340000000000000, 379999999999999) `suchThat` isAmericanExpress

-- > quickCheck (forAll americanExpressNum prop_AmericanExpress)
prop_AmericanExpress :: Integer -> Bool
prop_AmericanExpress = isAmericanExpress

masterNum1 :: Gen Integer
masterNum1 = choose (5100000000000000, 5599999999999999) `suchThat` isMaster

-- > quickCheck (forAll masterNum1 prop_Master1)
prop_Master1 :: Integer -> Bool
prop_Master1 = isMaster

masterNum2 :: Gen Integer
masterNum2 = choose (2221000000000000, 2720999999999999) `suchThat` isMaster

-- > quickCheck (forAll masterNum2 prop_Master2)
prop_Master2 :: Integer -> Bool
prop_Master2 = isMaster

visaNum :: Gen Integer
visaNum = choose (4000000000000000, 4999999999999999) `suchThat` isVisa

-- > quickCheck (forAll visaNum prop_Visa)
prop_Visa :: Integer -> Bool
prop_Visa = isVisa

-- Assignment 8

data Boy = Matthew | Peter | Jack | Arnold | Carl
           deriving (Eq,Show)

boys :: [Boy]
boys = [Matthew, Peter, Jack, Arnold, Carl]

accuses :: Boy -> Boy -> Bool
accuses Matthew Arnold = True
accuses Matthew Jack   = True
accuses Matthew Peter  = True
accuses Matthew _      = False

accuses Peter Jack    = True
accuses Peter Matthew = True
accuses Peter _       = False

accuses Jack Arnold  = True
accuses Jack Carl    = True
accuses Jack Matthew = True
accuses Jack _       = False

accuses Arnold Carl    = True
accuses Arnold Matthew = True
accuses Arnold _       = False

accuses Carl Arnold = True
accuses Carl Jack   = True
accuses Carl Peter  = True
accuses Carl _      = False

accusers :: Boy -> [Boy]
accusers boy = filter (`accuses` boy) boys

{-
  Possible solution:
    -Generate combinations of three boys, those which tell the truth
    -Now check if for that combination, there is a singleton list
-}

-- guilty :: [Boy]
-- honest :: [Boy]

